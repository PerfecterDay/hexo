---
title: 操作系统综述
date: 2018-05-30 19:50:07
tags: os
category: os
---

### 实模式
x86架构的cpu在启动时都是进入的实模式，实模式的特点是：
0. 指令的寻址方式不同，操作数一般16位。
1. 16位的寄存器，20位地址线，最大只能访问1M内存。
2. 内存访问方式是段地址*16+偏移地址构成内存的物理地址，且可以通过在程序中修改段基址来访问任意的真实物理内存，并修改。这样用户程序与系统程序一样，拥有至高无上的权利甚至可以修改操作系统的内存。
3. 因为只有16位寄存器，所以一个段最多只能是64KB大小，超过这个大小就要切换段基址来访问更大范围的内存区域。
4. 一次只能运行一个程序。

写一个实模式的程序，你要了解你的程序将会被加载到内存的什么位置，然后将合适的段加载到内存中合适的位置（没有被他人占用），并且初始化各个数据段寄存器的值，以保证其正确地指向各个段基址。恶意程序可以访问任意的物理地址，包括更改操作系统占用内存。

### 保护模式
保护模式的一些特性：
0. 指令寻址方式扩展。操作数扩展到32位。
1. 除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器等都扩展到32位，地址总线和数据总线为32位。
   ![寄存器扩展](/pics/register-extend.png)
2. 通过段描述符来描述一段内存，包括段基址、段大小、特权级、权限、属性等等。许多描述符组成全局段描述符表，存储在内存中。 每个段描述符8个字节。
3. GDTR：48位寄存器保存GDT全局描述符表在内存中的段基址及大小，前32位为GDT在内存中的起始地址，后16位为GDT的大小。所以段描述符表最多存储2^16/2^3=2^13个段。
4. 每个程序都可以在全局描述符表中定义自己的段描述符。
5. 保护模式下的段寄存器叫做段选择子，0~1位用来存储RPL(请求特权级),第2位代表是在GDT还是在LDT中，3~15位为索引，表示在GDT或者LDT表中的索引。

进入保护模式的步骤：
1. 打开A20地址线
2. 填写GDT表并将其加载到 GDTR
3. 将CR0寄存器的PE位置1。

### 保护模式下的内存访问过程：

#### 分段内存访问（段部件功能）
![保护模式下的内存访问](/pics/segment.png)

因为
1. 段描述符（段描述符表）是在内存中，访问内存比较慢
2. 段描述符格式怪异（历史原因），CPU需要额外操作对其进行整合才能根据其中的内容访问内存。
所以，有个段描述符缓冲寄存器，根据局部性原理，访问一个断后一段时间内将会继续访问该段，段描述符缓冲寄存器用来缓存段描述符避免重复计算。

#### 特权级
1. CPU分为4个特权级 ring0/1/2/3，现代操作系统一般只用了0和3，不同特权级下的权限不同，比如一些特权指令只能在0下运行。
2. 每个特权级下都有一个独立的栈，所以最多有4个特权级栈，切换特权级时，也要切换栈。所以说**系统调用是需要开销的**(除了栈切换，还有参数传递和上下文保存的开销)

#### 开启分页
开启分页后的内存访问：
![一级页表访存过程](/pics/first-page-table.png)
![二级页表访存过程](/pics/secondary-page-table.png)
图中的段部件就是上文中未开启分页时的访存过程。

#### 内存规划
一个用户进程在保护模式下，所有占用的资源（地址空间）就是在分配给它的页表来定义的。基于上述分析：
1. 如果简单来说，所有用户进程都可以分为两个段：代码段和数据段。操作系统加载程序时，可以定义这两个段的DPL为3，且段选择子的RPL也定义为3，这就是为啥用户进程运行在3的原因。且这两个段能被所有的进程共享，因为最终地址是由页表决定的，只要不同进程定义不同的页表，就不会造成地址冲突。
2. 用户进程一般都会使用操作系统提供的功能（系统调用），操作系统的功能是被所有进程共享的，所以所有进程的页表中，关于系统内核部分的都是一样的。这也就是通常所说的用户4G空间被分成高1G内核空间和3G用户空间的原因。而且因为是相同的页表项，可以考虑用二级页表被所有一级页表引用，节省内存。