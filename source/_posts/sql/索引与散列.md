---
title: 索引与散列
date: 2018-06-11 15:18:20
tags: sql
category: sql
---
## 基本概念
超码：是一个或多个属性的集合，超码中属性的组合可以使我们在这个关系中唯一的标识一个元组。
候选码：如果K是一个超码，那么任何K的超集也是超码。如果一个超码的任意真子集都不能成为超码，这样的最小超码称为候选码。
主码：选定用来唯一标识关系中一个元组的候选码。
外码：一个关系（r1）可能在它的属性中包含另一个关系模式（r2)的主码。这个属性在r1上称作参照r2的外码。r1称作外码的参照关系，r2称作外码的被参照关系。

顺序索引：基于值的顺序索引。
散列索引：基于将值通过散列函数平均分布到若干散列桶中。
搜索码：用于在文件中查找记录的属性或属性集合称为搜索码。

## 顺序索引
每个索引结构与一个特定的搜索码相关联。正如书中的索引或者图书馆目录一样，顺序索引按照顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。

被索引文件中的记录自身也可以按照某种排序顺序存储，正如图书馆的书按某些属性顺序排放一样。一个文件可以有多个索引，分别基于不同的搜索码。如果包含记录的文件按照某个搜索码索引指定的顺序将记录排序，那么该搜索码对应的索引成为**聚集索引**，也称为**主索引**。搜索码指定的顺序与文件中记录的物理顺序不同的索引称为**非聚集索引**或**辅助索引**。

在搜索码上有聚集索引的文件称为**索引顺序文件**。

### 稠密索引和稀疏索引
**索引项**或**索引记录**由一个搜索码值和指向具有该搜索码值的一条或多条记录的指针构成。指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量。

可以使用的顺序索引有两类：

* 稠密索引：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密聚集索引中，索引项包括搜索码值以及指向具有该搜索码值第一条数据记录的指针。具有相同搜索码值的其余记录顺序地存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的搜索码值排序。
在稠密非聚集索引中，索引必须存储指向所有相同搜索码值的记录的指针列表。

* 稀疏索引：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储记录时才能使用稀疏索引，换句话说，只有索引是**聚集索引**时才能使用稀疏索引。为了使用索引查找一条记录，首先找到小于或等于待查搜索码值的索引项，然后从该索引项指向的记录开始，沿着文件中的记录指针查找知道找到所需记录为止。
![稀疏索引和稠密索引](/pics/index.jpg)

因为，稠密索引为每个不同的搜索码都建立了索引项，利用稠密索引通常可以更快地定位一条记录。但是，稀疏索引也有优越的地方：它所占的存储空间较小，并且插入和删除时所需的维护开销也较小。

系统设计者必须在存取时间和空间开销之间进行权衡，尽管这一权衡的决定依赖于具体的应用，但是为每个块建立一个索引项的稀疏索引是一个较好的折中。利用稀疏索引快速定位到块后，将块读取到内存，在内存中扫描整个块的时间与定位磁盘块的时间相比可以忽略。只要记录不在溢出块中，就能使块访问次数最小，同时保持索引尽可能的小。

**文件中的记录按照A搜索码有序组织排列，没有按B搜索码有序排列。那么，A搜索码上的索引称为聚集索引（可以是稠密也可以是稀疏的），在B搜索码的上的为辅助索引（稠密索引）。
如为每个记录搜索码建立索引项就是稠密索引，反之就是稀疏索引。**

### 辅助索引
辅助索引必须是稠密索引，对每个搜索码值都要有一个索引项，而且对文件中的每条记录都有一个指针。而聚集索引可以是稀疏索引，只要找到一个合适的记录，然后顺序扫描部分文件即可找到指定记录。但是，非聚集索引不能是稀疏的，因为搜索码乱序排放，所以有可能造成整个文件扫描才能找到指定记录。

## B+ 树索引
B+树是一种多级索引，但是其结构不同于多级索引顺序文件。典型的B+树结点结构如下图所示。它最多包含 n-1 个搜索码值 $K_1,K_2,....K_(n-1)$ ，以及 n 个指针 $P_1,P_2,....,P_n$。每个结点中的搜索码值按序排放，因此如果 $i&lt;j$ ,则 $K_i&lt;K_j$。
![B+树结点](/pics/b+tree-node.jpg)
+ 叶节点结构
对于i=1,2,3....n-1,指针 Pi指向具有搜索码值 K_i 的一条文件记录。指针 $P_n$ 指向下一个有序的叶结点。叶结点最多包含 n-1 个搜索码值，最少包含 $\lceil (n-1)/2\rceil$ 个结点。 如果 Li，Lj是两个叶结点，且 i&lt;j，那么Li中的所有搜索码值小于等于Lj中的所有搜索码值。这种排序好且依次链接起来的叶结点实际上直接可以作为索引使用（叶结点链表顺序索引文件）。
+ 非叶结点
B+树的非叶结点形成叶结点上的一个多级（稀疏）索引。非叶结点结构和叶结点结构相同，只不过非叶结点中所有指针都指向树中的结点，而不是文件记录。非叶结点最多容纳n个指针，同时必须至少容纳$\lceil n/2\rceil$个指针，结点的指针数称为该结点的扇出。
![B+树索引结构](/pics/b+tree.png)
叶子结点通常通过双向指针来构成一个双向循环链表。

### B+树文件组织
不仅可以把B+树作为索引来使用，而且可以把它作为一个文件中记录的组织者，称为 B+树文件组织。树的叶节点存储的是记录而不是指向记录的指针。  
Mysql的 Innodb 引擎中，表数据都是根据主键顺序组织的一张索引组织表，就是按B+树组织的。每张表都要有主键，如果创建表时没有显式创建主键，会按如下方式创建主键：
+ 判断是否有定义非空的唯一索引，如果有，索引列就是主键
+ 如果不符合上述条件， Innodb 会自动创建一个6字节大小的主键。

### 辅助索引和记录重定位
一些文件组织（如B+树文件组织）可能会改变记录的位置，即使记录并没有更新。举例来说，当B+树文件组织中的一个叶节点分裂，一些记录会移动到新的节点中去。在这种情况下，所有存储了那些指向重定位过的记录的指针的辅助索引都必须更新，即使记录中的值没有更新。每个叶节点可能包含相当多的记录，而其中每条记录都可能在每个辅助索引中的不同位置。因此一个叶节点的分裂可能包含相当多的记录，而其中每条记录都可能在每个辅助索引的不同位置。因此一个叶节点的分裂可能需要几十甚至上百次IO操作来更新所有影响到的辅助索引，这个代价极其高昂。

为了解决这个问题，可以在辅助索引中不存储指向记录的指针，而是存储主索引搜索码属性的值（主键值）。于是，由于叶节点分裂导致的记录重定位就不需要对辅助索引进行更新了。

但是，用辅助索引定位一条记录需要两步：
1. 用辅助索引找到主索引码的值
2. 用主索引码去主索引中找到对应记录

### 前缀压缩
使用前缀压缩技术可以增加节点的扇出（出度）。不用在非叶节点存储整个搜索码值。只需存储每个搜索码的一个前缀，使得这个前缀足以将由该搜索码值分开的两棵子树中的码值区分开。

例如，假设有一个名字上的索引，非叶节点的码值可以使用名字的一个前缀；如果搜索码分开的两棵子树中跟"Siberdsfsd"最相近的码值分别是"Silas"和"Silver"，则在非叶节点中存储"Silb"前缀就可以了，而不用存储整个"Siberdsfsd"。

### 批量加载技术
考虑这样一种情况：要在一个超大关系表中的某个搜索码上建立非聚集索引，也就是说文件记录并没有按照该搜索码有序组织。

在这种情况下，当往B+树中添加项时，首先要查找需要将该项插入到哪个叶结点中，要访问的每个叶结点通常不在缓冲区中，因为项没有特定的排序，需要IO读取叶结点的块。每次项的插入都需要这样一次随机的读和写操作。假设一个关系有1亿条记录，每次IO需要10ms，那么建立这个非聚集索引至少需要100万秒的时间，这仅仅是读取叶结点的时间。

将大量向记录一次插入到索引中称为索引的批量加载。通常在数据库表已经存在大量数据且需要创建索引，或者将大量记录一次插入到数据库表中时（需要更新索引）。

一种有效执行批量加载的方式如下：
1. 首先，创建一个含有关系索引项的临时文件
2. 然后，根据构建好的索引（如果已经构建好）的搜索码来排序文件
3. 最后，扫描排序好的文件并且将项插入到索引中。

将项插入到B+树之前先进性排序具有明显的好处。排序后，可以顺序地将一批项插入到叶结点中（而不是一项一次IO地去查找叶结点）。如果是新建索引，即初始B+树为空，批量加载时就不需要从磁盘中加载叶结点。如果连续叶结点也分配到连续磁盘块中，那么就可以顺序IO操作叶结点。相比于随机IO操作的每块10ms，大部分顺序IO操作只需要1ms。从零开始构建B+树索引时，可以采用**自底向上B+树构建**。而不是使用常规的插入过程。

**自底向上B+树构建**中，通过扫描将项排序后的临时文件，将排序好的项分解到块中，并保证每个快中有尽可能多的项，由此产生的块形成B+树的叶级。每个块中的最小值及指向块中的指针用来构建下一级B+树的项，并且指向叶块。更深一级的树结点可以类似的使用下层结点中的最小值来构建，直到跟结点。

大多数数据库系统使用基于项排序和**自底向上B+树构建**的有效技术。如果一次插入大量数据记录到已经存在的关系中，一些数据库会建议先删除索引（除了主码上的索引），然后重新构建该索引。

### 多码访问

#### 使用多个单码索引
假设关系 instructor 的 dept_name 和 salary 上分别都建立了索引。考虑下面的查询：
`select * from instructor where dept_name='Finace' and salary = 8000 `
有三种策略：
1. 利用dept_name索引，找出属于金融系的所有记录，检查每条记录是否满足 salary = 8000；
2. 利用 salary 索引，找出所有 salary < 8000 的记录，检查每条记录是否满足 dept_name='Finace'；
3. 分别利用 salary 索引和 dept_name 索引检索出满足条件的两个指针集合，计算两个集合的交集。

只有第三种方法利用了存在多个索引的优势。但是这种策略在下面这种情况下也是很糟糕的选择：
+ 属于金融系的记录很多
+ salary = 8000的记录很多
+ 金融系中 salary = 8000的记录很少

#### 使用多码索引(联合索引)
另一种可选的策略是在复合搜索码（dept_name,salary)上建立索引。下图是一个多码索引的结构：
![多码索引B+树结构](/pics/multi-index.jpg)
可以看出，叶子节点是按照多个搜索码的排序的，多码索引会先对第一个搜索码排序，然后对第二个..。也就是说如果多个记录第一个搜索码相同，会按照第二个搜索码的顺序排列，依此类推。所以，多码索引和第一个搜索码上的单码索引等价，整个索引是按照第一搜索码有序排列的。但是，后续搜索码在二叉查找树中不是有序的。

判断某搜索能不能使用一个某个索引的方法：搜索条件中的搜索码在该索引中是否是有序的（即是否能按二叉查找树排序规则排序）。

因此，使用多码索引时，有最左前缀原则：只有搜索条件中是多码索引的最左前缀时，才可以利用多码索引。
 (col1, col2, col3，col4)这个联合索引的所有前缀就是(col1), (col1, col2), (col1, col2, col3), (col1, col2, col3，col4)。(col2), (col3), (col2, col3) 都不会使用该索引。但是，（col1，col3）会使用col1部分索引，（col1,col2,col4)会使用（col1,col2）的索引。总结来说就是：搜索条件中的搜索码必须可以匹配到多码索引前缀的一个或多个，最终匹配最长的部分会使用多码索引。

### 覆盖索引
覆盖索引存储一些属性（但不是搜索码属性）的值以及指向记录的指针。存储附加的属性值对于辅助索引是非常有用的，因为它们使得使用索引就能回答在附加属性的的一些查询，甚至不需要找到实际的记录。

### 倒排索引
![倒排索引](/pics/reverse-index.png)

## 索引操作SQL
1. 创建索引
    + `create [unique] index <index_name> on <table_name>(column_list)`
    + `alter table <table_name> add [index|key] <index_name>(column_list)`: `alter table t add key idx_b(b(5))`->只对b列的前5个数据进行索引，假如b列是字符串，就只索引前5个字符
2. 删除索引
    + `drop index <index_name> on <table_name>`
    + `alter table <table_name> drop primary key| drop [index|key] <index_name>`
3. 查看索引
`show index from <table_name>`