---
title: 数据库事务
date: 2018-06-11 21:56:30
tags: sql   
category: sql
---

## 事务的概念
**事务**是访问并可能更新各种数据项的一个程序执行单元。这些步骤集合必须作为一个单一的、不可分割的单元出现。

## 事务的特性
1. **原子性(Atomicity)**：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映(全或无)。
2. **一致性(Consistency)**：隔离执行事务时(换言之，在没有其它数据库事务并发执行的情况下)保持数据库的一致性。
3. **隔离性(Isolation)**：尽管多个事务可以并发执行，但系统保证，对于任何一对事务T<sub>i</sub>和T<sub>j</sub>,在T<sub>i</sub>看来，T<sub>j</sub>或者在T<sub>i</sub>开始之前完成，或者在T<sub>i</sub>完成之后开始执行。因此，每个事务都感觉不到系统中有其它事务在并发地执行。
4. **持久性(Durability)**：一个事务完成之后，它对数据库的改变是永久性的，即使出现系统故障。

## 实例分析
下边是一个从账户A转账$50到账户B的事务：
read(x):代表把数据库项x读取到内存缓冲区中一个叫x的变量操作；
write(x):代表把内存缓冲区中一个叫x的变量写入到数据库项x中；

![事务](/pics/transaction.jpg)

* 一致性：在这里要求事务的执行不改变A、B账户金额之和。如果没有一致性要求，金额可能被事务凭空创造或销毁。如果数据库在事务执行前是一致的，那么在事务执行后仍将保持一致。确保单个事务的一致性是编写该事务的应用程序员的职责。
* 原子性：假设事务执行前，A、B分别有$1000和$2000。假设T<sub>i</sub>执行时系统出现故障，在Write(A)之后、Write(B)之前，这样的话，数据库反映出来的转态是A有$950而B有$2000。这样，数据库反映的状态不再是本应描述的现实世界的真实状态。这种状态称为不一致状态。我们必须保证这种不一致状态在数据库中是不可见的。但是请注意，系统必然在某一时刻处于这种不一致状态。即使T<sub>i</sub>不出现故障，在执行过程中，也存在瞬时不一致状态。这样，如果一个事务或者不开始，或者保证完成，那么这个不一致状态除了在事务执行当中以外，其它时刻是不可见的。这就是需要保证原子性的原因。保证数据库原子性是数据库系统本身的责任，由恢复系统组件来完成。
* 持久性：持久性意味着一旦事务执行成功，在系统中产生的所有变化将是永久的。应该存在一些检查点防止在系统失败时丢失信息。甚至硬件本身失败，系统的状态仍能通过在日志中记录事务完成的任务进行重建。我们可以通过确保下面两条中的任何一条来保证持久性：
    1. 事务做的更新在事务结束期已经更新到磁盘上。
    2. 有关事务已执行的更新信息已写到磁盘上，并且信息必须充分，能让数据库系统在重启时重新构造更新。可以把相关更新信息保存到日志中。
    
    这项任务也是由恢复系统来保证的。

* 隔离性：如果几个事务并发的执行，即使每个事务都能确保一致性和原子性，如果他们的操作会以人们不希望的某种方式交叉执行，也会导致不一致的状态。假如在上述事务执行到不一致状态的瞬时，另一个事务读取A、B账户余额的值并计算A+B，得到的将是不一致的值。一种可行的方案是使事务一个接一个的执行，而不采用并发执行的方式。事务的隔离性保证保证事务的并发执行后的状态与这些事务一个接一个执行后的状态等价。这是有数据库系统的并发控制系统保证的。

## 事务的隔离级别
在标准SQL规范中定义了四种隔离级别：

+ 未提交读（Read Uncommitted）：最低隔离级别，一个事务能读取到别的事务未提交的更
新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；
+ 提交读(Read Committed)：一个事务能读取到别的事务提交的更新数据，不能看到未提交
的更新数据，不可能可能出现丢失更新、脏读，但可能出现不可重复读、幻读。例如：当一个事务两次读取一个数据项期间，另一个事务更新了该数据项并提交。
+ 可重复读（Repeatable Read）：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不允许更新该数据。但该事务不要求与其他事务可串行化。例如：当一个事务在查询满足条件的数据时，可能找到一个已提交的事务插入的一些数据，但可能找不到该事务插入的其他数据。
+ 序列化(Serializable)：最高隔离级别，保证可串行化执行，最安全，不可能出现丢失更新、脏读、不可重复读、幻读。

隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。因此在实际项目开发中为了考虑并发性能一般使用提交读隔离级别，它能避免丢失更新和脏读，尽管不可重复读和幻读不能避免，但可以在可能出现的场合使用**悲观锁**或**乐观锁**来解决这些问题。

可重复读和幻读的区别：
不可重复读是指一个事务在两次读取一个数据项时，返回的结果不同。在两次读取期间，该数据项被另一个事务修改了。（update)
幻读是指一个事务在两次查询符合某个条件的数据时，返回的结果集不同。在两次查询期间，另一个事务插入或删除了符合条件的新数据。（insert、delete）
注意上述中的两次是指系统中事务的两次随机执行，而不是一个事务中的两次查询，因为事务并发顺序不同，两次事务执行结果可能不同。

## 查看并设置隔离级别

```
-- 查看事务隔离级别
SHOW VARIABLES LIKE 'transaction_isolation';
SELECT @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;
SELECT @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;
```

```
/*
    设置事务隔离级别
*/
SET [GLOBAL | SESSION] TRANSACTION
    transaction_characteristic [, transaction_characteristic] ...

transaction_characteristic: {
    ISOLATION LEVEL level
  | access_mode
}

level: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}

access_mode: {
     READ WRITE
   | READ ONLY
}
set session TRANSACTION ISOLATION LEVEL READ COMMITTED
```
|Syntax	|Affected Characteristic Scope|
|:--:|:--:|
|SET GLOBAL TRANSACTION transaction_characteristic	|Global|
|SET SESSION TRANSACTION transaction_characteristic	|Session|
|SET TRANSACTION transaction_characteristic	|Next transaction only|


## 开启一个事务
大多数数据库引擎都是支持事务的.
InnoDB具有事务，支持4个事务隔离级别，回滚，崩溃修复能力和多版本并发的事务安全，包括ACID。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能

MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。

```
--设置自动提交值
SET autocommit = {0 | 1}

--开启一个事务
START TRANSACTION
    [transaction_characteristic [, transaction_characteristic] ...]

transaction_characteristic: {
    WITH CONSISTENT SNAPSHOT
  | READ WRITE
  | READ ONLY
}
BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
```
使用 autocommit 可以开启或关闭自动提交，默认是开启的。所以我们执行一条 update 或 insert 语句，不用 commit 就可以立即生效了。如果关闭了 autocommit 则必须手动 commit 才会生效。 START TRANSACTION 或 BEGIN 语句会关闭 autocommit 直到 commit 或 rollback后， autocommit 才会恢复到之前的状态（如果之前是开启）。autocommit 是与 session绑定的，必须为每个 session 设置。

START TRANSACTION 与 BEGIN 语句是一样的，前者是 SQL 标准语法，推荐使用，后者是 MySql 自家语法。

### 事务的实现原理
事务的隔离性通常由并发控制策略来实现，原子性、一致性和持久性一般由恢复系统来实现。Mysql 的恢复系统使用了 redo log 和 undo log 来完成。 redo log 称为重做日志，用来保证事务的原子性和持久性， undo log 称为回滚日志，用来保证一致性。