---
title: CSS 综述
date: 2019-06-22 18:03:24
tags: css web
category: css
---

## CSS 语句

### 规则集
通过在每个声明块前加上选择器（selector）来将一组声明块应用到选择器选择的元素上，选择器是一种模式，它能在页面上匹配一些元素。这将使相关的声明块仅被应用到被选择的元素上。选择器加上声明块被称为**规则集（ruleset）**，通常简称**规则（rule）**。
![规则](/pics/css-rule.jpg)

一个元素可以被多个选择器所匹配，因此，一个给定的属性可能被多个规则设置多次。 CSS 定义了哪个规则比其它规则更具优先级，则更具优先级的规则必定被应用：这被称为**层叠算法（cascade algorithm）**，关于层叠算法的更多内容和运作原理见层叠和继承。

### @-规则
**@-规则(At-rules)**在CSS中被用来传递元数据、条件信息或其它描述性信息。它由（@）符号开始，紧跟着一个表明它是哪种规则的描述符，之后是这种规则的语法块，并最终由一个半角分号（;）结束。每种由描述符定义的@-规则，都有其特有的内部语法和语义。一些例子如下：
+ @charset 和 @import （元数据）
+ @media 或 @document （条件信息，又被称为嵌套语句，见下方。)
+ @font-face （描述性信息）
具体语法示例：
`@import 'custom.css'; //该@-规则向当前 CSS 导入其它 CSS 文件`

### 嵌套语句
**嵌套语句** 是@-规则中的一种，它的语法是 CSS 规则的嵌套块，只有在特定条件匹配时才会应用到文档上。特定条件如下：
+ @media 只有在运行浏览器的设备匹配其表达条件时才会应用该@-规则的内容；
+ @supports 只有浏览器确实支持被测功能时才会应用该@-规则的内容；
+ @document 只有当前页面匹配一些条件时才会应用该@-规则的内容。

任何不是规则集或@-规则或嵌套语句的 CSS 语句都是无效的，并会因此被忽略。

## CSS 选择器
选择器可以被分为以下类别：
+ 简单选择器（Simple selectors）：通过元素类型、class 或 id 匹配一个或多个元素。
+ 属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。
+ 伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。
+ 伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 
+ 组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。
+ 多重选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。

### 简单选择器
“简单”选择器，之所以这么称呼它是因为它们基于元素的类型（或其 class或 id）直接匹配文档的一个或多个元素。

#### 类型选择器（又名元素选择器）
此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。

#### 类选择器
类选择器由一个点“.”以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。

#### ID 选择器节
ID选择器是由一个哈希/磅符号 (#)，后面跟着给定元素的ID名称组成的。 任何元素都可以使用id属性设置唯一的ID名称。 由你自己决定选择一个ID名称是什么。 这是选择单个元素的最有效的方式。

注意：一个ID名称必须在文档中是唯一的。关于重复ID的行为是不可预测的，比如一些浏览器只是计入第一个实例，其余的将被忽略

#### 通用选择器
通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际价值，更常见的做法是与其他选择器结合使用。

### 属性选择器
属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 
+ 存在和值属性选择器
+ 子串值属性选择器。

#### 存在和值（Presence and value）属性选择器
这些属性选择器尝试匹配精确的属性值：
+ [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。
+ [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。
+ [attr~=val]：该选择器仅选择具有 attr 属性的元素，而且要求 val 值是 attr 值包含的被空格分隔的取值列表里中的一个。

#### 子串值（Substring value）属性选择器
这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）：
+ [attr|=val] : 选择attr属性的值是 val 或值以 val- 开头的元素（注意，这里的 “-” 不是一个错误，这是用来处理语言编码的）。
+ [attr^=val] : 选择attr属性的值以 val 开头（包括 val）的元素。
+ [attr$=val] : 选择attr属性的值以 val 结尾（包括 val）的元素。
+ [attr*=val] : 选择attr属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）。

### 伪选择器
伪选择器 。该选择器不是选择元素，而是元素的某些部分，或仅在某些特定上下文中存在的元素。它们有两种主要类型 ：
+ 伪类
+ 伪元素。

#### 伪类（Pseudo-class）
一个 CSS  伪类（pseudo-class） 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。下面是一些伪类示例：
+ :active
+ :any
+ :checked
+ :default
+ :dir()

#### 伪元素
伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::) ， 同样是添加到选择器后面去选择某个元素的某个部分。
+ ::after
+ ::before
+ ::first-letter
+ ::first-line
+ ::selection
+ ::backdrop

### 组合器和选择器组
|名称      |组合器| 选择|
|-----|-----:|-----:|
|选择器组|	A,B	|匹配满足A（和/或）B的任意元素（参见下方 同一规则集上的多个选择器）.|
|后代选择器|	A B	|匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）|
|子选择器|	A > B	|匹配B元素，满足条件：B是A的直接子节点|
|相邻兄弟选择器|	A + B	|匹配B元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）|
|通用兄弟选择器|	A ~ B	|匹配B元素，满足条件：B是A之后的任意一个兄弟节点（AB有相同的父节点，B在A之后，但不一定是紧挨着A）| 

## CSS数值与单位

## 层叠
当有多个选择器匹配到同一个元素上时，哪个选择器的 CSS 规则最终会应用到元素上？
什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）：
1. 重要性（Importance）
2. 专用性（Specificity）
3. 源代码次序（Source order）

### 重要性
在CSS中，有一个特别的语法可以让一条规则总是优先于其他规则：`!important` 。把它加在属性值的后面可以使这条声明有无比强大的力量。
相互冲突的声明将按以下顺序适用，后一种将覆盖先前的声明：
1. 在用户代理样式表的声明 (例如：浏览器在没有其他声明的默认样式).
2. 用户样式表中的普通声明（由用户设置的自定义样式）。
3. 作者样式表中的普通声明（这是我们设置的样式，Web开发人员）。
4. 作者样式表中的重要声明
5. 用户样式表中的重要声明

### 专用性
一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字：
1. 千位：如果声明是在style 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。
2. 百位：在整个选择器中每包含一个ID选择器就在该列中加1分。
3. 十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。
4. 个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。
通用选择器 (*), 复合选择器 (+, >, ~, ' ') 和否定伪类 (:not) 在专用性中无影响。如果多个选择器具有相同的重要性和专用性，则选择哪一个选择器取决于 Source order.

下表显示了几个示例。试着通过这些，并确保你理解他们为什么具有我们给予他们的专用性。

|选择器|	千位|	百位|	十位|	个位|	合计值|
|----|----|----|-----|-----|------|
|h1|	0|	0|	0|	1|	0001|
|#indentifier|	0|	1|	0|	0|	0100|
|h1 + p::first-letter|	0|	0|	0|	3|	0003|
|li > a[href*="zh-CN"] > .inline-warning|	0|	0|	2|	2|	0022|
|没有选择器, 规则在一个元素的 &lt;style&gt; 属性里|	1|	0|	0|	0|	1000|

在考虑所有这些层叠理论和什么样式优先于其他样式被应用时，你应该记住的一件事是，所有这些都发生在属性级别上——属性覆盖其他属性，但你不会让整个规则凌驾于其他规则之上。
当多个CSS规则匹配相同的元素时，它们都被应用到该元素中。只有在这之后，任何相互冲突的属性才会被评估，以确定哪种风格会战胜其他类型。

### 继承
CSS为处理继承提供了四种特殊的通用属性值：
+ inherit： 该值将应用到选定元素的属性值设置为与其父元素一样。
+ initial ：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 inherit。
+ unset ：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 inherit，否则就是表现得像 initial。
+ revert ：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。