---
title: java基础-并发之底层原理
date: 2019-04-15 20:17:27
tags: java
category: java
---

## 处理器如何实现原子操作
处理器提供 Lock 前缀的指令，Lock 前缀指令在多核处理器下会引发两件事情：
1. 将当前数据所在的处理器缓存行写回内存。
2. 缓存行写回内存操作在 MESI(修改、独占、共享、无效) 协议下，会使其他处理器里缓存了该数据的缓存行失效，导致重新从内存加载。

### 使用总线锁
处理器提供的一个 `LOCK#` 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

（有个疑问，多线程时，有可能同一个处理器上并发呀，那么处理器级别的独享内存并不能隔离线程？）。
跑在同一个CPU上的线程，共享变量缓存，修改对所有线程可见。

### 使用缓存锁
总线锁会阻塞其他处理器所有的总线请求，假设其他处理器请求访问的不是同一个地址，也会被阻塞，开销会比较大。缓存锁定是指内存如果被缓存到缓存行中的话，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不会在总线上声言 `LOCK#` 信号，缓存一致性机制会使其他处理器缓存的该缓存行失效。

但是有两种情况不会使用缓存锁定：
1. 当操作的数据不能缓存到 cache 中，或操作数跨多个缓存行时，处理器会调用总线锁定。
2. 处理器不支持缓存锁定时。

## synchronized 锁实现原理
1. 对于同步方法，锁的是当前对象
2. 对于静态同步方法，锁的是当前类的 Class 对象
3. 对于同步方法块，锁的是 synchronized 括号里的对象

任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，它将处于锁定状态。 monitorenter指令用来尝试获取锁， monitorexit 指令释放锁。

### Java对象头
![Java对象头长度](/pics/java对象头长度.png)
Java对象头的 Mark Word 里存放着对象的 HashCode 、分代年龄和锁标记位。32位 JVM 的 Mark Word 的变化如下：
![Java对象头长度](/../../pics/mark-word变化状态.png)
### 锁
Java SE 1.6 中，锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁可以升级但不能降级。

#### 偏向锁
#### 轻量级锁


## Java实现原子操作的方式
Java 中可以使用 CAS 和锁来实现原子操作。

### 循环CAS实现原子操作
百度百科，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切 [1]  换到另一个线程）。

CMPXCHG:比较交换原子操作指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上CPU中支持。

比较后交换原子操作原语：

    long __stdcall CompareExchange(long volatile*Destination,long Exchange,long Comperand) 
    { 
        __asm 
        { 
            mov     ecx, Destination; 
            mov     edx, Exchange; 
            mov     eax, Comperand; 
            lock cmpxchg [ecx], edx; 
        } 
    }
注意上述 [ecx] 代表的是共享内存。比较并交换其实是一个 RMW (Read-Modify-Write)操作，若不能保证原子性，就不能保证执行的安全性。
JVM 中如果循环调用上述原语函数，直到 [ecx] 内存处的值被更新为 edx 寄存器中的值，就能提供原子更新的方法。
#### CAS的三大问题
1. ABA 问题
2. 循环时间开销大：如果 CAS 长时间不成功，会导致 CPU 一直在执行 CAS 操作。
3. 只能保证一个共享变量的原子操作。

### 使用锁机制实现原子操作
锁机制保证了只有获得了锁的线程才能进入临界区操作锁定的内存区域。JVM 内部实现了多种锁：偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了 CAS，即当一个线程想进入同步块的时候使用循环CAS获取锁，当它退出时，使用循环CAS释放锁。