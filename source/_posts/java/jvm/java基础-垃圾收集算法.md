---
title: java基础-垃圾收集
date: 2019-05-02 09:28:17
tags: java
category: java
---
## 垃圾收集算法
### 标记-清除算法
最基础的收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记对象。它的主要不足有两个：
1. 效率问题，标记和清除两个过程的效率都不高
2. 空间碎片问题，标记清除之后会产生大量不连续的内存碎片，空间碎片可能会导致后续分配大对象时，无法找到足够的连续内存而触法另一次垃圾收集动作。
![标记清除算法示意图](/pics/标记-清除算法.png)

### 复制算法
复制算法将可用内存划分为大小相等的两块，每次只能*轮流*使用其中*一块*。当其中一块内存用完了，就将存活的对象一次性的复制到另一块内存中，并对当前内存块一次性清除（全部清除掉），后续内存分配在另一块内存中进行。这样，每次垃圾收集都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片问题，只要移动堆顶指针按顺序分配即可（指针碰撞），实现简单，分配高效；它的不足之处在于：可用内存缩减为原来的一半，浪费率太高了；而且，如果 GC 后，存活对象较多，那么将要复制一大批对象，也会降低效率。因此复制算法适用于存活率较低的场景。
![复制算法示意图](/pics/复制算法.png)

IBM 公司的专门研究表明，新生代中的对象 98% 是朝生夕死的，就是说进行垃圾回收的时候，大约只有 2% 会存活下来。那么我们可以想想有没有什么办法不用浪费一半的内存空间呢？将内存去划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。分配比例是 8:1:1 ，这样，只有 10% 的空间被浪费。至于为什么需要两块 Survivor ？ 想象一下，假设只有一块 Survivor ，那么当轮到在 Survivor 块中分配空间时，因为空间很小，所以很快就会因为内存不够而触发 GC，频繁触发 GC 会影响性能。

另外，我们不能保证每次 GC 后，只有 10% 的对象存活，当 Survivor 空间不够时，需要依赖其它内存（老年代）进行分配担保。GC 后如果存活对象大于 10%，会将 GC 代数（每次GC后，存活对象GC代数增加）较久的对象复制到老年代。

### 标记-整理算法
复制收集算法在对象存活率较高时需要进行较多的复制操作，效率会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存所有对象 100% 存活的极端情况，所以老年代一般不会直接使用这种算法。

根据老年代的特点：存活率较高，有人提出了一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有活的对象都像一端移动，然后直接清理掉端边界以外的内存。
![标记-整理算法](/pics/标记-整理算法.png)

### 分代收集
当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法没有什么新思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代。新生代中，每次垃圾收集都有大批对象死去，就选用复制算法。而老年代中因为对象存活率较高、没有额外空尽进行担保，就使用“标记-清除”或这“标记-整理”算法。
